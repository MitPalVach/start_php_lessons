<?php

//  Массив - это набор данных, которые объединены под одним именем. Массив состоит из нескольких элементов, которые имеют свой определенный индекс.
//  Имена массивов начинаются со знака $, после которого следует произвольный идентификатор, далее идут квадратные скобки: $arr[0] = "php";
//  Данная конструкция создает массив и присваивает его элементу с индексом 0 значение "php",
//  после чего мы можем обращаться к этому элементу как к обычной переменной: echo $arr[0]. В результате мы увидим слово php.

//  ====================================================================================== Модификация элементов массива
//  Если нужно изменить значение того, или иного элемента массива, для этого нужно всего лишь обратится к элементу
//  массива по его индексу и присвоить ему новое значение.
$arr_fruit[0] = 'apple';
$arr_fruit[1] = 'lemon';
$arr_fruit[2] = 'banana';
$arr_fruit[] = 'chery';
$arr_fruit[2] = 'pineapple';
foreach ($arr_fruit as $key => $value) { // при переборе: $key - индекс элемента массива, $value - значение элемента массива
    var_dump($arr_fruit);
}
//  ========================================================================================= Удаление элементов массива
//  Если нужно удалить один из элементов массива, то использовать функцию unset

$arr_veg[0] = 'carrot';
$arr_veg[1] = 'potato';
$arr_veg[2] = 'bean';
var_dump($arr_veg);
unset($arr_veg[1]);
foreach ($arr_veg as $key => $value) {
    var_dump($arr_veg);
}
//  ================================================================================================ Сортировка массивов
//  sort - сортирует массив по возрастанию значений его элементов, при этом изменяя индекс после сортировки
//  так же есть, и другие
//  rsort - сортирует массив по убыванию значений его элементов, при этом не изменяя индекс после сортировки
//  ksort - сортирует массив по ключам, сохраняя отношения между ключами и значениями
//  krsort - сортирует массив по убыванию индексов его элементов
$arr_colors[0] = 'red';
$arr_colors[1] = 'green';
$arr_colors[2] = 'blue';
sort($arr_colors); //  в данном случае выведет в алф. порядке
    print_r($arr_colors); //  print_r выводит элементы массива вместе с их индексами
echo '<br>';
//  ============================================================================================== Навигация по массивам
//  Навигация по массива дает возможно узнать текущий , следующий, предыдущий, последний элемента массива.
$arr_street[0] = 'Fuchika';
$arr_street[1] = 'Chishmale';
$arr_street[2] = 'Tabeeva';
var_dump($arr_street);
echo 'Now is ', current($arr_street), '<br>'; //  Для определения текущего элемента массива используют функцию current
echo 'Next is ', next($arr_street), '<br>'; //  Для определения следующего элемента массива используют функцию next
echo 'Previously is ', prev($arr_street), '<br>'; //  Для определения предыдущего элемента массива используют функцию prev
echo 'The end is ', end($arr_street), '<br>'; //  Для определения последнего элемента массива используют функцию end
echo 'First is ', reset($arr_street), '<br>'; //  Для определения первого (возврата указателя) элемента массива используют функцию reset
//  ========================================================================== Преобразование строк в массивы и наоборот
//  Преобразовывать данные из строки в массив и наоборот, для этого в PHP есть функция implode и explode.
$arr_tech[0] = 'TV';
$arr_tech[1] = 'Computer';
$arr_tech[2] = 'Lamp';
$str_tech = implode(', ', $arr_tech);
echo $str_tech . '<br>';  //  Выдает строку через запятую
// -----
$str_tech1 = 'Ref, Phone, Notebook';
$arr_tech1 = explode(', ', $str_tech1);
print_r($arr_tech1) . '<br>';  //  Выдает массив с индексом элемента
echo '<br>';
//  ================================================================================== Извлечение переменных из массивов
//  Если есть потребность для массива, который проиндексированн строчными данным, присвоить значение переменным,
//  одноименным с соответствующими индексами, то можно использовать функцию extract.
$arr_num["one"] = 1;
$arr_num["two"] = 2;
$arr_num["three"] = 3;
extract($arr_num);
//echo "\$one = $one <br>";
// ??????????????????????????????????????????????????????????

echo '<br>';
//  Если нужно сложить из переменных массив, то нужно использовать функцию compact.
$one = 1;
$two = 2;
$three = 3;
$arr_num1 = compact('one', 'two', 'three');
print_r($arr_num1);
echo '<br>';
//  ====================================================================================== Слияние и разделение массивов
//  Если нужно добавить в массив несколько элементов другого массива, то нужна функция array_slice
$arr_home['one'] = 'Sofa';
$arr_home['two'] = 'Table';
$arr_home['three'] = 'Chair';
$new_arr_home = array_slice($arr_home, 0,2);
print_r($new_arr_home);
echo '<br>';
//  Первый параметр функции array_slice - это название того массива, с которого будут браться элементы;
//  второй - начальный номер элемента (с какого элемента начинать брать элементы); третий - количество элементов выборки.
$arr_soft[1] = 'PHP';
$arr_soft[2] = 'HTML';
$arr_soft[3] = 'CSS';
$arr_soft_dop[1] = 'Photoshop';
$arr_soft_dop[2] = 'Corel';
$arr_soft_dop[3] = 'Paint';
$new_arr_soft = array_merge($arr_soft, $arr_soft_dop);
print_r($new_arr_soft); //  Для соединения массивов в один нужно использовать функцию array_merge:
echo '<br>';
//  ================================================================================================= Сравнение массивов
//  Если нужно проверить какой элемент совпадает в массиве, или НЕ совпадает, то можно использовать функцию array_diff
$i_color_arr[1] = 'i_red';
$i_color_arr[2] = 'i_green';
$i_color_arr[3] = 'i_blue';
$a_color_arr[1] = 'i_red';
$a_color_arr[2] = 'a_green';
$a_color_arr[3] = 'a_blue';
$diff = array_diff($i_color_arr, $a_color_arr);
print_r($diff);
echo '<br>';
//  Если нужно, чтобы сравнивался еще и строковый индекс массивов, то уже нужно использовать функцию array_diff_assoc
//  Если нужно найти общие элементы массивов, то вам поможет функция array_intersect
//  Если при нахождении общих элементов массивов нужно учесть и индекс, то, используйте функцию array_intersect_assoc
//  ======================================================================================== Обработка данных в массивах
//  Если нужно вычислить сумму всех элементов массив, то можно воспользоваться функцией array_sum
$arr_number[1] = 14;
$arr_number[2] = 32;
$arr_number[3] = 56;
$sum = array_sum($arr_number);
echo $sum;
echo '<br>';
//  Если, требуется избавиться от элементов с повторяющимся значением, то стоит использовать функцию array_unique
$arr_repeat = array(32, 54, 64, 32, 95, 64, 95);
print_r($arr_repeat);
echo '<br>';
$sum_2 = array_unique($arr_repeat);
print_r($sum_2);
echo '<br>';
//  ================================================================================================ Многомерные массивы
//  Многомерные массивы имеют под одним индексом два или более значений.
//  Например, есть массив companies, который имеет информацию об предложениях по работе, от разных компаний
$companies['Microsoft'][1] = 'Programmer';
$companies['Microsoft'][2] = 'PR';
$companies['Microsoft'][3] = 'Manager';
$companies['Google'][1] = 'IT';
$companies['Google'][2] = 'Programmer';
$companies['Mozilla'][1] = 'PR';
$companies['Mozilla'][2] = 'IT';
print_r($companies);
//  тоже самое:
$companies = [
  'Microsoft' => ['Programmer', 'PR', 'Manager'],
  'Google' => ['IT', 'Programmer'],
  'Mozilla' => ['PR', 'IT']
];
echo '<pre>'; //  pre - выравнивает вывод на экран в лучше читаемые колонки
print_r($companies);
echo '</pre>';
//  ======================================================================== Использование циклов в многомерных массивах
$companies_1[0][] = 'Programmer';
$companies_1[0][] = 'PR';
$companies_1[1][] = 'IT';
$companies_1[1][] = 'Manager';
$companies_1[2][] = 'PR';
$companies_1[2][] = 'Programmer';
for ($i = 0; $i < count($companies_1); $i++) {
    for ($j = 0; $j < count($companies_1[$i]); $j++) {
        echo $companies_1[$i][$j], '<br>';
    }
}
//  Переменная $i отвечает за счет в первых квадратных скобках массива, а переменная $j за счет во вторых квадратных
//  скобках массива. Второй цикл FOR работает, пока в массиве не закончатся элементы определенного индекса.

















